From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: M2ke4U <wangxyper@163.com>
Date: Sat, 24 Jun 2023 08:10:05 +0800
Subject: [PATCH] Add PCASync,BBOR,CarpetAlternativeBlockPlacement from Leaves


diff --git a/src/main/java/me/earthme/molia/MoliaConfig.java b/src/main/java/me/earthme/molia/MoliaConfig.java
index 8dc09260c390fc988342e13f53d520a300a6170a..28b48b0c80d51b98501c2d6f767aed0a6cbd5661 100644
--- a/src/main/java/me/earthme/molia/MoliaConfig.java
+++ b/src/main/java/me/earthme/molia/MoliaConfig.java
@@ -23,6 +23,9 @@ public class MoliaConfig {
 
     //Gameplay
     public static boolean enableFakePlayer = true;
+    public static boolean enablePCASyncProtocol = false;
+    public static boolean enableBBORProtocol = false;
+    public static String pcaSyncPlayerEntity = "NOBODY";
 
     //Fake player
     public static boolean enableFakePlayerSkipSleep = true;
@@ -52,6 +55,9 @@ public class MoliaConfig {
         disableFoliaPluginCheck = getBoolean("unsafe.disable_folia_plugin_check",disableFoliaPluginCheck);
 
         enableFakePlayer = getBoolean("gameplay.enable_fake_player",enableFakePlayer);
+        enablePCASyncProtocol = getBoolean("gameplay.enable_pca_sync_protocol",enablePCASyncProtocol);
+        enableBBORProtocol = getBoolean("gameplay.enable_bbor_protocol",enableBBORProtocol);
+        pcaSyncPlayerEntity = getString("gameplay.pca_sync_player_entity",pcaSyncPlayerEntity);
 
         enableFakePlayerSkipSleep = getBoolean("fakeplayer.enable_fake_player_skip_sleep",enableFakePlayerSkipSleep);
         fakePlayerSizeLimit = getInt("fakeplayer.fake_player_size_limit",fakePlayerSizeLimit);
diff --git a/src/main/java/net/minecraft/server/MinecraftServer.java b/src/main/java/net/minecraft/server/MinecraftServer.java
index b1adb4000987021be2c5e3ac1184f3266aae3a57..74757637e8e762e129b5dc8aa3160d19ad5a019c 100644
--- a/src/main/java/net/minecraft/server/MinecraftServer.java
+++ b/src/main/java/net/minecraft/server/MinecraftServer.java
@@ -1721,6 +1721,8 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
 
         this.profiler.popPush("server gui refresh");
 
+        top.leavesmc.leaves.protocol.BBORProtocol.tick(); // Leaves - bbor
+
         MinecraftTimings.tickablesTimer.startTiming(); // Spigot // Paper
         if (region == null) for (int i = 0; i < this.tickables.size(); ++i) {  // Folia - region threading - TODO WTF is this?
             ((Runnable) this.tickables.get(i)).run();
diff --git a/src/main/java/net/minecraft/server/network/ServerGamePacketListenerImpl.java b/src/main/java/net/minecraft/server/network/ServerGamePacketListenerImpl.java
index b2feaea169fa9d3977c3dfdfdf3dea9283f5d854..7f53e93edf39a9882fd7c39fe7d555570e6f2af1 100644
--- a/src/main/java/net/minecraft/server/network/ServerGamePacketListenerImpl.java
+++ b/src/main/java/net/minecraft/server/network/ServerGamePacketListenerImpl.java
@@ -245,6 +245,7 @@ import org.bukkit.inventory.CraftingInventory;
 import org.bukkit.inventory.EquipmentSlot;
 import org.bukkit.inventory.InventoryView;
 import org.bukkit.inventory.SmithingInventory;
+import top.leavesmc.leaves.util.ProtocolUtils;
 // CraftBukkit end
 
 public class ServerGamePacketListenerImpl implements ServerPlayerConnection, TickablePacketListener, ServerGamePacketListener {
@@ -3598,6 +3599,19 @@ public class ServerGamePacketListenerImpl implements ServerPlayerConnection, Tic
                 this.disconnect("Invalid payload UNREGISTER!", org.bukkit.event.player.PlayerKickEvent.Cause.INVALID_PAYLOAD); // Paper - kick event cause
             }
         } else {
+            // Leaves start - leaves extra protocol
+            try {
+                if (top.leavesmc.leaves.LeavesConfig.pcaSyncProtocol && ProtocolUtils.isNamespacePacket(packet, top.leavesmc.leaves.protocol.PcaSyncProtocol.PROTOCOL_ID)) {
+                    top.leavesmc.leaves.protocol.PcaSyncProtocol.handlePacket(server, player, packet);
+                }
+                if (top.leavesmc.leaves.LeavesConfig.bborProtocol && packet.identifier.equals(top.leavesmc.leaves.protocol.BBORProtocol.SUBSCRIBE)) {
+                    top.leavesmc.leaves.protocol.BBORProtocol.onPlayerSubscribed(player);
+                }
+            } catch (Exception ex) {
+                ServerGamePacketListenerImpl.LOGGER.error("Couldn\'t dispatch custom payload", ex);
+                this.disconnect("Invalid custom payload!", org.bukkit.event.player.PlayerKickEvent.Cause.INVALID_PAYLOAD);
+            }
+            // Leaves end - leaves extra protocol
             try {
                 byte[] data = new byte[packet.data.readableBytes()];
                 packet.data.readBytes(data);
diff --git a/src/main/java/net/minecraft/server/players/PlayerList.java b/src/main/java/net/minecraft/server/players/PlayerList.java
index 374473a85a1384a428612b89e9c767cfaf3ff397..ef5da5bccf0400c07eec560b46fcbc4a0dd2c869 100644
--- a/src/main/java/net/minecraft/server/players/PlayerList.java
+++ b/src/main/java/net/minecraft/server/players/PlayerList.java
@@ -436,6 +436,8 @@ public abstract class PlayerList {
                 bot1.render(playerconnection, true,player.getBukkitEntity().getWorld() == bot1.getBukkitEntity().getWorld())); // Leaves - render bot
         }
         // Leaves end - bot support
+        top.leavesmc.leaves.protocol.PcaSyncProtocol.onJoin(player); // Leaves - pca
+        top.leavesmc.leaves.protocol.BBORProtocol.onPlayerLoggedIn(player); // Leaves - bbor
 
         final net.kyori.adventure.text.Component jm = playerJoinEvent.joinMessage();
 
@@ -684,6 +686,7 @@ public abstract class PlayerList {
         return this.remove(entityplayer, net.kyori.adventure.text.Component.translatable("multiplayer.player.left", net.kyori.adventure.text.format.NamedTextColor.YELLOW, io.papermc.paper.configuration.GlobalConfiguration.get().messages.useDisplayNameInQuitMessage ? entityplayer.getBukkitEntity().displayName() : PaperAdventure.asAdventure(entityplayer.getDisplayName())));
     }
     public net.kyori.adventure.text.Component remove(ServerPlayer entityplayer, net.kyori.adventure.text.Component leaveMessage) {
+        top.leavesmc.leaves.protocol.BBORProtocol.onPlayerLoggedOut(entityplayer); // Leaves - bbor
         // Paper end
         ServerLevel worldserver = entityplayer.serverLevel();
 
@@ -1681,7 +1684,7 @@ public abstract class PlayerList {
             entityplayer.connection.send(packetplayoutrecipeupdate);
             entityplayer.getRecipeBook().sendInitialRecipeBook(entityplayer);
         }
-
+        top.leavesmc.leaves.protocol.BBORProtocol.onDataPackReload(); // Leaves - bbor
     }
 
     public boolean isAllowCheatsForAllPlayers() {
diff --git a/src/main/java/net/minecraft/world/entity/animal/horse/AbstractHorse.java b/src/main/java/net/minecraft/world/entity/animal/horse/AbstractHorse.java
index 9b35a50eb99551f28d45fd5114e0401b4c54646e..d806c2d56bdc8452ce037caa50bb16ce472df437 100644
--- a/src/main/java/net/minecraft/world/entity/animal/horse/AbstractHorse.java
+++ b/src/main/java/net/minecraft/world/entity/animal/horse/AbstractHorse.java
@@ -7,6 +7,8 @@ import java.util.function.DoubleSupplier;
 import java.util.function.IntUnaryOperator;
 import java.util.function.Predicate;
 import javax.annotation.Nullable;
+
+import me.earthme.molia.MoliaConfig;
 import net.minecraft.advancements.CriteriaTriggers;
 import net.minecraft.core.BlockPos;
 import net.minecraft.core.Direction;
@@ -379,6 +381,11 @@ public abstract class AbstractHorse extends Animal implements ContainerListener,
 
     @Override
     public void containerChanged(Container sender) {
+        // Leaves start - pca
+        if (MoliaConfig.enablePCASyncProtocol) {
+            top.leavesmc.leaves.protocol.PcaSyncProtocol.syncEntityToClient(this);
+        }
+        // Leaves end - pca
         boolean flag = this.isSaddled();
 
         this.updateContainerEquipment();
diff --git a/src/main/java/net/minecraft/world/entity/npc/AbstractVillager.java b/src/main/java/net/minecraft/world/entity/npc/AbstractVillager.java
index 1e1e79a9156d73299e27d70f76b39fd721346327..29a178ca9024974ffaadab54bf10d258b0291965 100644
--- a/src/main/java/net/minecraft/world/entity/npc/AbstractVillager.java
+++ b/src/main/java/net/minecraft/world/entity/npc/AbstractVillager.java
@@ -4,6 +4,8 @@ import com.google.common.collect.Sets;
 import java.util.Iterator;
 import java.util.Set;
 import javax.annotation.Nullable;
+
+import me.earthme.molia.MoliaConfig;
 import net.minecraft.advancements.CriteriaTriggers;
 import net.minecraft.core.particles.ParticleOptions;
 import net.minecraft.nbt.CompoundTag;
@@ -65,6 +67,15 @@ public abstract class AbstractVillager extends AgeableMob implements InventoryCa
         super(type, world);
         this.setPathfindingMalus(BlockPathTypes.DANGER_FIRE, 16.0F);
         this.setPathfindingMalus(BlockPathTypes.DAMAGE_FIRE, -1.0F);
+        // Leaves start - pca
+        if (!this.level().isClientSide()) {
+            this.inventory.addListener(inventory -> {
+                if (MoliaConfig.enablePCASyncProtocol) {
+                    top.leavesmc.leaves.protocol.PcaSyncProtocol.syncEntityToClient(this);
+                }
+            });
+        }
+        // Leaves end - pca
     }
 
     @Override
diff --git a/src/main/java/net/minecraft/world/entity/vehicle/AbstractMinecartContainer.java b/src/main/java/net/minecraft/world/entity/vehicle/AbstractMinecartContainer.java
index 272095d7a09ab41227d741172735f66fd2798ce1..066552b41cb504b57e6d645849548ba30c212023 100644
--- a/src/main/java/net/minecraft/world/entity/vehicle/AbstractMinecartContainer.java
+++ b/src/main/java/net/minecraft/world/entity/vehicle/AbstractMinecartContainer.java
@@ -1,6 +1,8 @@
 package net.minecraft.world.entity.vehicle;
 
 import javax.annotation.Nullable;
+
+import me.earthme.molia.MoliaConfig;
 import net.minecraft.core.NonNullList;
 import net.minecraft.nbt.CompoundTag;
 import net.minecraft.resources.ResourceLocation;
@@ -129,7 +131,13 @@ public abstract class AbstractMinecartContainer extends AbstractMinecart impleme
     }
 
     @Override
-    public void setChanged() {}
+    public void setChanged() {
+        // Leaves start - pca
+        if (MoliaConfig.enablePCASyncProtocol) {
+            top.leavesmc.leaves.protocol.PcaSyncProtocol.syncEntityToClient(this);
+        }
+        // Leaves end - pca
+    }
 
     @Override
     public boolean stillValid(Player player) {
diff --git a/src/main/java/net/minecraft/world/item/BlockItem.java b/src/main/java/net/minecraft/world/item/BlockItem.java
index ebee8de2ed831755b6fd154f6cc77ac993839bb9..1015b3c5f6969709bb8ebfbd66eb9cede444385c 100644
--- a/src/main/java/net/minecraft/world/item/BlockItem.java
+++ b/src/main/java/net/minecraft/world/item/BlockItem.java
@@ -158,7 +158,7 @@ public class BlockItem extends Item {
 
     @Nullable
     protected BlockState getPlacementState(BlockPlaceContext context) {
-        BlockState iblockdata = this.getBlock().getStateForPlacement(context);
+        BlockState iblockdata = this.getBlock().getRealStateForPlacement(context); // Leaves - carpetAlternativeBlockPlacement
 
         return iblockdata != null && this.canPlace(context, iblockdata) ? iblockdata : null;
     }
diff --git a/src/main/java/net/minecraft/world/item/StandingAndWallBlockItem.java b/src/main/java/net/minecraft/world/item/StandingAndWallBlockItem.java
index 39b8b3675ac58409e05fac07e07c8016c5280d81..928b1ece5b094dee8a5e37bfd3afd626cb1bd03a 100644
--- a/src/main/java/net/minecraft/world/item/StandingAndWallBlockItem.java
+++ b/src/main/java/net/minecraft/world/item/StandingAndWallBlockItem.java
@@ -34,7 +34,7 @@ public class StandingAndWallBlockItem extends BlockItem {
     @Nullable
     @Override
     protected BlockState getPlacementState(BlockPlaceContext context) {
-        BlockState iblockdata = this.wallBlock.getStateForPlacement(context);
+        BlockState iblockdata = this.wallBlock.getRealStateForPlacement(context); // Leaves - carpetAlternativeBlockPlacement
         BlockState iblockdata1 = null;
         Level world = context.getLevel();
         BlockPos blockposition = context.getClickedPos();
@@ -45,7 +45,7 @@ public class StandingAndWallBlockItem extends BlockItem {
             Direction enumdirection = aenumdirection[j];
 
             if (enumdirection != this.attachmentDirection.getOpposite()) {
-                BlockState iblockdata2 = enumdirection == this.attachmentDirection ? this.getBlock().getStateForPlacement(context) : iblockdata;
+                BlockState iblockdata2 = enumdirection == this.attachmentDirection ? this.getBlock().getRealStateForPlacement(context) : iblockdata; // Leaves - carpetAlternativeBlockPlacement
 
                 if (iblockdata2 != null && this.canPlace(world, iblockdata2, blockposition)) {
                     iblockdata1 = iblockdata2;
diff --git a/src/main/java/net/minecraft/world/level/block/Block.java b/src/main/java/net/minecraft/world/level/block/Block.java
index 52dda8e8074e0f894d9ef95b46bd937dae629f14..e920f0a4191fdc6bae68b1952d3ee4814b0fd2a1 100644
--- a/src/main/java/net/minecraft/world/level/block/Block.java
+++ b/src/main/java/net/minecraft/world/level/block/Block.java
@@ -11,6 +11,8 @@ import java.util.List;
 import java.util.function.Function;
 import java.util.function.Supplier;
 import javax.annotation.Nullable;
+
+import me.earthme.molia.MoliaConfig;
 import net.minecraft.SharedConstants;
 import net.minecraft.Util;
 import net.minecraft.core.BlockPos;
@@ -411,6 +413,19 @@ public class Block extends BlockBehaviour implements ItemLike {
 
     public void stepOn(Level world, BlockPos pos, BlockState state, Entity entity) {}
 
+    // Leaves start - carpetAlternativeBlockPlacement
+    @Nullable
+    public BlockState getRealStateForPlacement(BlockPlaceContext ctx) {
+        if (MoliaConfig.enablePCASyncProtocol) {
+            BlockState tryState = top.leavesmc.leaves.protocol.CarpetAlternativeBlockPlacement.alternativeBlockPlacement(this, ctx);
+            if (tryState != null) {
+                return tryState;
+            }
+        }
+        return getStateForPlacement(ctx);
+    }
+    // Leaves end - carpetAlternativeBlockPlacement
+
     @Nullable
     public BlockState getStateForPlacement(BlockPlaceContext ctx) {
         return this.defaultBlockState();
diff --git a/src/main/java/net/minecraft/world/level/block/entity/AbstractFurnaceBlockEntity.java b/src/main/java/net/minecraft/world/level/block/entity/AbstractFurnaceBlockEntity.java
index 448fa4f4f200430d6ce3051763c7ceb697696146..5d60ea837a5382df5e0d0569036ba9c45d9a8bcc 100644
--- a/src/main/java/net/minecraft/world/level/block/entity/AbstractFurnaceBlockEntity.java
+++ b/src/main/java/net/minecraft/world/level/block/entity/AbstractFurnaceBlockEntity.java
@@ -9,6 +9,8 @@ import java.util.Iterator;
 import java.util.List;
 import java.util.Map;
 import javax.annotation.Nullable;
+
+import me.earthme.molia.MoliaConfig;
 import net.minecraft.SharedConstants;
 import net.minecraft.Util;
 import net.minecraft.core.BlockPos;
@@ -569,6 +571,16 @@ public abstract class AbstractFurnaceBlockEntity extends BaseContainerBlockEntit
 
     }
 
+    // Leaves start - pca
+    @Override
+    public void setChanged() {
+        super.setChanged();
+        if (MoliaConfig.enablePCASyncProtocol) {
+            top.leavesmc.leaves.protocol.PcaSyncProtocol.syncBlockEntityToClient(this);
+        }
+    }
+    // Leaves end - pca
+
     @Override
     public boolean stillValid(net.minecraft.world.entity.player.Player player) {
         return Container.stillValidBlockEntity(this, player);
diff --git a/src/main/java/net/minecraft/world/level/block/entity/BarrelBlockEntity.java b/src/main/java/net/minecraft/world/level/block/entity/BarrelBlockEntity.java
index 416aa989ebb18a8741cc9d605a1180ab830f6643..b7a0ae307abf25a4aa36f267ddcdb7e68a0a6b5b 100644
--- a/src/main/java/net/minecraft/world/level/block/entity/BarrelBlockEntity.java
+++ b/src/main/java/net/minecraft/world/level/block/entity/BarrelBlockEntity.java
@@ -1,5 +1,6 @@
 package net.minecraft.world.level.block.entity;
 
+import me.earthme.molia.MoliaConfig;
 import net.minecraft.core.BlockPos;
 import net.minecraft.core.Direction;
 import net.minecraft.core.NonNullList;
@@ -131,6 +132,16 @@ public class BarrelBlockEntity extends RandomizableContainerBlockEntity {
         this.items = list;
     }
 
+    // Leaves start - pca
+    @Override
+    public void setChanged() {
+        super.setChanged();
+        if (MoliaConfig.enablePCASyncProtocol) {
+            top.leavesmc.leaves.protocol.PcaSyncProtocol.syncBlockEntityToClient(this);
+        }
+    }
+    // Leaves end - pca
+
     @Override
     protected Component getDefaultName() {
         return Component.translatable("container.barrel");
diff --git a/src/main/java/net/minecraft/world/level/block/entity/BeehiveBlockEntity.java b/src/main/java/net/minecraft/world/level/block/entity/BeehiveBlockEntity.java
index 41c9f074203915c31c1ae7a160ce509c13383f84..99d9c6317109ac99d6d379ce405e735c0cc54a94 100644
--- a/src/main/java/net/minecraft/world/level/block/entity/BeehiveBlockEntity.java
+++ b/src/main/java/net/minecraft/world/level/block/entity/BeehiveBlockEntity.java
@@ -4,7 +4,10 @@ import com.google.common.collect.Lists;
 import java.util.Arrays;
 import java.util.Iterator;
 import java.util.List;
+import java.util.Objects;
 import javax.annotation.Nullable;
+
+import me.earthme.molia.MoliaConfig;
 import net.minecraft.core.BlockPos;
 import net.minecraft.core.Direction;
 import net.minecraft.nbt.CompoundTag;
@@ -127,6 +130,11 @@ public class BeehiveBlockEntity extends BlockEntity {
             super.setChanged();
         }
 
+        // Leaves start - pca
+        if (MoliaConfig.enablePCASyncProtocol) {
+            top.leavesmc.leaves.protocol.PcaSyncProtocol.syncBlockEntityToClient(this);
+        }
+        // Leaves end - pca
         return list;
     }
 
@@ -188,6 +196,12 @@ public class BeehiveBlockEntity extends BlockEntity {
                 this.level.gameEvent(GameEvent.BLOCK_CHANGE, blockposition, GameEvent.Context.of(entity, this.getBlockState()));
             }
 
+            // Leaves start - pca
+            if (MoliaConfig.enablePCASyncProtocol) {
+                top.leavesmc.leaves.protocol.PcaSyncProtocol.syncBlockEntityToClient(this);
+            }
+            // Leaves end - pca
+
             entity.discard();
             super.setChanged();
         }
@@ -334,6 +348,11 @@ public class BeehiveBlockEntity extends BlockEntity {
                 if (BeehiveBlockEntity.releaseOccupant(world, pos, state, tileentitybeehive_hivebee, (List) null, tileentitybeehive_releasestatus, flowerPos)) {
                     flag = true;
                     iterator.remove();
+                    // Leaves start - pca
+                    if (top.leavesmc.leaves.LeavesConfig.pcaSyncProtocol) {
+                        top.leavesmc.leaves.protocol.PcaSyncProtocol.syncBlockEntityToClient(Objects.requireNonNull(world.getBlockEntity(pos)));
+                    }
+                    // Leaves end - pca
                     // CraftBukkit start
                 } else {
                     tileentitybeehive_hivebee.exitTickCounter = tileentitybeehive_hivebee.minOccupationTicks / 2; // Not strictly Vanilla behaviour in cases where bees cannot spawn but still reasonable // Paper - use exitTickCounter to keep actual bee life
@@ -385,6 +404,11 @@ public class BeehiveBlockEntity extends BlockEntity {
             this.maxBees = nbt.getInt("Bukkit.MaxEntities");
         }
         // CraftBukkit end
+        // Leaves start - pca
+        if (top.leavesmc.leaves.LeavesConfig.pcaSyncProtocol) {
+            top.leavesmc.leaves.protocol.PcaSyncProtocol.syncBlockEntityToClient(this);
+        }
+        // Leaves end - pca
     }
 
     @Override
diff --git a/src/main/java/net/minecraft/world/level/block/entity/BrewingStandBlockEntity.java b/src/main/java/net/minecraft/world/level/block/entity/BrewingStandBlockEntity.java
index 526d1bfd5ad0de7bcfd0c2da902515f3dec94c54..8d0b34ebedac52356f1b1470ec3e133d143dc3a7 100644
--- a/src/main/java/net/minecraft/world/level/block/entity/BrewingStandBlockEntity.java
+++ b/src/main/java/net/minecraft/world/level/block/entity/BrewingStandBlockEntity.java
@@ -3,6 +3,8 @@ package net.minecraft.world.level.block.entity;
 import java.util.Arrays;
 import java.util.Iterator;
 import javax.annotation.Nullable;
+
+import me.earthme.molia.MoliaConfig;
 import net.minecraft.core.BlockPos;
 import net.minecraft.core.Direction;
 import net.minecraft.core.NonNullList;
@@ -333,6 +335,16 @@ public class BrewingStandBlockEntity extends BaseContainerBlockEntity implements
 
     }
 
+    // Leaves start - pca
+    @Override
+    public void setChanged() {
+        super.setChanged();
+        if (MoliaConfig.enablePCASyncProtocol) {
+            top.leavesmc.leaves.protocol.PcaSyncProtocol.syncBlockEntityToClient(this);
+        }
+    }
+    // Leaves end - pca
+
     @Override
     public boolean stillValid(Player player) {
         return Container.stillValidBlockEntity(this, player);
diff --git a/src/main/java/net/minecraft/world/level/block/entity/ChestBlockEntity.java b/src/main/java/net/minecraft/world/level/block/entity/ChestBlockEntity.java
index a71414397bd45ee7bcacfeef0041d80dfa25f114..4d59d7da7af95c1f947257159cea992a5424186a 100644
--- a/src/main/java/net/minecraft/world/level/block/entity/ChestBlockEntity.java
+++ b/src/main/java/net/minecraft/world/level/block/entity/ChestBlockEntity.java
@@ -1,5 +1,6 @@
 package net.minecraft.world.level.block.entity;
 
+import me.earthme.molia.MoliaConfig;
 import net.minecraft.core.BlockPos;
 import net.minecraft.core.Direction;
 import net.minecraft.core.NonNullList;
@@ -190,6 +191,16 @@ public class ChestBlockEntity extends RandomizableContainerBlockEntity implement
         this.items = list;
     }
 
+    // Leaves start - pca
+    @Override
+    public void setChanged() {
+        super.setChanged();
+        if (MoliaConfig.enablePCASyncProtocol) {
+            top.leavesmc.leaves.protocol.PcaSyncProtocol.syncBlockEntityToClient(this);
+        }
+    }
+    // Leaves end - pca
+
     @Override
     public float getOpenNess(float tickDelta) {
         return this.chestLidController.getOpenness(tickDelta);
diff --git a/src/main/java/net/minecraft/world/level/block/entity/DispenserBlockEntity.java b/src/main/java/net/minecraft/world/level/block/entity/DispenserBlockEntity.java
index 881379681c39230a00b3a1f11cd87498984396c7..826705d7246b36840ab50765a30d9b8b7258ce89 100644
--- a/src/main/java/net/minecraft/world/level/block/entity/DispenserBlockEntity.java
+++ b/src/main/java/net/minecraft/world/level/block/entity/DispenserBlockEntity.java
@@ -1,5 +1,6 @@
 package net.minecraft.world.level.block.entity;
 
+import me.earthme.molia.MoliaConfig;
 import net.minecraft.core.BlockPos;
 import net.minecraft.core.NonNullList;
 import net.minecraft.nbt.CompoundTag;
@@ -92,6 +93,16 @@ public class DispenserBlockEntity extends RandomizableContainerBlockEntity {
         return -1;
     }
 
+    // Leaves start - pca
+    @Override
+    public void setChanged() {
+        super.setChanged();
+        if (MoliaConfig.enablePCASyncProtocol) {
+            top.leavesmc.leaves.protocol.PcaSyncProtocol.syncBlockEntityToClient(this);
+        }
+    }
+    // Leaves end - pca
+
     @Override
     protected Component getDefaultName() {
         return Component.translatable("container.dispenser");
diff --git a/src/main/java/net/minecraft/world/level/block/entity/HopperBlockEntity.java b/src/main/java/net/minecraft/world/level/block/entity/HopperBlockEntity.java
index 4825a74ce4893dafdb70ae1badf3d2e1930d01a1..4925d29d4113760ad0b81d394fc1a1795a2d6a13 100644
--- a/src/main/java/net/minecraft/world/level/block/entity/HopperBlockEntity.java
+++ b/src/main/java/net/minecraft/world/level/block/entity/HopperBlockEntity.java
@@ -6,6 +6,8 @@ import java.util.function.BooleanSupplier;
 import java.util.stream.Collectors;
 import java.util.stream.IntStream;
 import javax.annotation.Nullable;
+
+import me.earthme.molia.MoliaConfig;
 import net.minecraft.core.BlockPos;
 import net.minecraft.core.Direction;
 import net.minecraft.core.NonNullList;
@@ -129,6 +131,16 @@ public class HopperBlockEntity extends RandomizableContainerBlockEntity implemen
 
     }
 
+    // Leaves start - pca
+    @Override
+    public void setChanged() {
+        super.setChanged();
+        if (MoliaConfig.enablePCASyncProtocol) {
+            top.leavesmc.leaves.protocol.PcaSyncProtocol.syncBlockEntityToClient(this);
+        }
+    }
+    // Leaves end - pca
+
     @Override
     protected Component getDefaultName() {
         return Component.translatable("container.hopper");
@@ -169,6 +181,11 @@ public class HopperBlockEntity extends RandomizableContainerBlockEntity implemen
                 if (flag) {
                     blockEntity.setCooldown(world.spigotConfig.hopperTransfer); // Spigot
                     setChanged(world, pos, state);
+                    // Leaves start - pca
+                    if (top.leavesmc.leaves.LeavesConfig.pcaSyncProtocol) {
+                        top.leavesmc.leaves.protocol.PcaSyncProtocol.syncBlockEntityToClient(blockEntity);
+                    }
+                    // Leaves end - pca
                     return true;
                 }
             }
diff --git a/src/main/java/net/minecraft/world/level/block/entity/ShulkerBoxBlockEntity.java b/src/main/java/net/minecraft/world/level/block/entity/ShulkerBoxBlockEntity.java
index b7686fd63b7c5d88c3a12ec4ee9bc01a17f997e0..5baaf3ba32b145797c037e147a5293df8c3842fe 100644
--- a/src/main/java/net/minecraft/world/level/block/entity/ShulkerBoxBlockEntity.java
+++ b/src/main/java/net/minecraft/world/level/block/entity/ShulkerBoxBlockEntity.java
@@ -3,6 +3,8 @@ package net.minecraft.world.level.block.entity;
 import java.util.List;
 import java.util.stream.IntStream;
 import javax.annotation.Nullable;
+
+import me.earthme.molia.MoliaConfig;
 import net.minecraft.core.BlockPos;
 import net.minecraft.core.Direction;
 import net.minecraft.core.NonNullList;
@@ -259,6 +261,16 @@ public class ShulkerBoxBlockEntity extends RandomizableContainerBlockEntity impl
         this.itemStacks = list;
     }
 
+    // Leaves start - pca
+    @Override
+    public void setChanged() {
+        super.setChanged();
+        if (MoliaConfig.enablePCASyncProtocol) {
+            top.leavesmc.leaves.protocol.PcaSyncProtocol.syncBlockEntityToClient(this);
+        }
+    }
+    // Leaves end - pca
+
     @Override
     public int[] getSlotsForFace(Direction side) {
         return ShulkerBoxBlockEntity.SLOTS;
diff --git a/src/main/java/net/minecraft/world/level/chunk/LevelChunk.java b/src/main/java/net/minecraft/world/level/chunk/LevelChunk.java
index 94edc970f64a2c0f89eb6666de21f0f01d1c1c9d..59d08ab6a436a6c87114abd5440c3ea889fa8a1d 100644
--- a/src/main/java/net/minecraft/world/level/chunk/LevelChunk.java
+++ b/src/main/java/net/minecraft/world/level/chunk/LevelChunk.java
@@ -970,6 +970,11 @@ public class LevelChunk extends ChunkAccess {
 
     public void setLoaded(boolean loadedToWorld) {
         this.loaded = loadedToWorld;
+        // Leaves start - bbor
+        if (loaded) {
+            top.leavesmc.leaves.protocol.BBORProtocol.onChunkLoaded(this);
+        }
+        // Leaves end - bbor
     }
 
     public Level getLevel() {
diff --git a/src/main/java/org/bukkit/craftbukkit/CraftServer.java b/src/main/java/org/bukkit/craftbukkit/CraftServer.java
index 3ce2ebeaf07a17a25ae16a42f5f98a91d530cacb..41364474ca672536bd8247d131760e4c1a577ceb 100644
--- a/src/main/java/org/bukkit/craftbukkit/CraftServer.java
+++ b/src/main/java/org/bukkit/craftbukkit/CraftServer.java
@@ -43,6 +43,8 @@ import java.util.logging.Level;
 import java.util.logging.Logger;
 import java.util.stream.Collectors;
 import javax.imageio.ImageIO;
+
+import me.earthme.molia.MoliaConfig;
 import net.minecraft.advancements.Advancement;
 import net.minecraft.commands.CommandSourceStack;
 import net.minecraft.commands.Commands;
@@ -471,6 +473,7 @@ public final class CraftServer implements Server {
             MapPalette.setMapColorCache(new CraftMapColorCache(this.logger));
         }
         datapackManager = new io.papermc.paper.datapack.PaperDatapackManager(console.getPackRepository()); // Paper
+        top.leavesmc.leaves.protocol.PcaSyncProtocol.init(); // Leaves - pca
     }
 
     public boolean getCommandBlockOverride(String command) {
@@ -1097,6 +1100,20 @@ public final class CraftServer implements Server {
 
         org.spigotmc.SpigotConfig.init((File) console.options.valueOf("spigot-settings")); // Spigot
         this.console.paperConfigurations.reloadConfigs(this.console);
+        // Leaves start - pca
+        if (MoliaConfig.enablePCASyncProtocol) {
+            top.leavesmc.leaves.protocol.PcaSyncProtocol.enablePcaSyncProtocolGlobal();
+        } else {
+            top.leavesmc.leaves.protocol.PcaSyncProtocol.disablePcaSyncProtocolGlobal();
+        }
+        // Leaves end - pca
+        // Leaves start - bbor
+        if (MoliaConfig.enableBBORProtocol) {
+            top.leavesmc.leaves.protocol.BBORProtocol.initAllPlayer();
+        } else {
+            top.leavesmc.leaves.protocol.BBORProtocol.loggedOutAllPlayer();
+        }
+        // Leaves end - bbor
         for (ServerLevel world : this.console.getAllLevels()) {
             // world.serverLevelData.setDifficulty(config.difficulty); // Paper - per level difficulty
             world.setSpawnSettings(world.serverLevelData.getDifficulty() != Difficulty.PEACEFUL && config.spawnMonsters, config.spawnAnimals); // Paper - per level difficulty (from MinecraftServer#setDifficulty(ServerLevel, Difficulty, boolean))
diff --git a/src/main/java/top/leavesmc/leaves/protocol/BBORProtocol.java b/src/main/java/top/leavesmc/leaves/protocol/BBORProtocol.java
new file mode 100644
index 0000000000000000000000000000000000000000..4f2ac4079e78d0c6dc5e09a31f2fb1f15e83c544
--- /dev/null
+++ b/src/main/java/top/leavesmc/leaves/protocol/BBORProtocol.java
@@ -0,0 +1,216 @@
+package top.leavesmc.leaves.protocol;
+
+import io.netty.buffer.Unpooled;
+import me.earthme.molia.MoliaConfig;
+import net.minecraft.core.BlockPos;
+import net.minecraft.core.Registry;
+import net.minecraft.core.registries.Registries;
+import net.minecraft.network.FriendlyByteBuf;
+import net.minecraft.resources.ResourceLocation;
+import net.minecraft.server.MinecraftServer;
+import net.minecraft.server.level.ServerLevel;
+import net.minecraft.server.level.ServerPlayer;
+import net.minecraft.world.level.chunk.LevelChunk;
+import net.minecraft.world.level.levelgen.structure.BoundingBox;
+import net.minecraft.world.level.levelgen.structure.Structure;
+import net.minecraft.world.level.levelgen.structure.StructurePiece;
+import net.minecraft.world.level.levelgen.structure.StructureStart;
+import org.jetbrains.annotations.Contract;
+import org.jetbrains.annotations.NotNull;
+import top.leavesmc.leaves.util.ProtocolUtils;
+
+import java.util.HashMap;
+import java.util.HashSet;
+import java.util.Map;
+import java.util.Set;
+import java.util.concurrent.ConcurrentHashMap;
+import java.util.stream.Collectors;
+
+public class BBORProtocol {
+
+    public static final String PROTOCOL_ID = "bbor";
+
+    // send
+    private static final ResourceLocation INITIALIZE_CLIENT = id("initialize");
+    private static final ResourceLocation ADD_BOUNDING_BOX = id("add_bounding_box_v2");
+    private static final ResourceLocation STRUCTURE_LIST_SYNC = id("structure_list_sync_v1");
+    // call
+    public static final ResourceLocation SUBSCRIBE = id("subscribe");
+    private static final Map<Integer, ServerPlayer> players = new ConcurrentHashMap<>();
+    private static final Map<Integer, Set<BBoundingBox>> playerBoundingBoxesCache = new HashMap<>();
+    private static final Map<ResourceLocation, Map<BBoundingBox, Set<BBoundingBox>>> dimensionCache = new ConcurrentHashMap<>();
+
+    private static final ServerLevel OVERWORLD = MinecraftServer.getServer().overworld();
+
+    @Contract("_ -> new")
+    public static @NotNull ResourceLocation id(String path) {
+        return new ResourceLocation(PROTOCOL_ID, path);
+    }
+
+    public static void onPlayerLoggedIn(@NotNull ServerPlayer player) {
+        if (MoliaConfig.enablePCASyncProtocol) {
+            FriendlyByteBuf buf = new FriendlyByteBuf(Unpooled.buffer());
+            buf.writeLong(OVERWORLD.getSeed());
+            buf.writeInt(OVERWORLD.levelData.getXSpawn());
+            buf.writeInt(OVERWORLD.levelData.getZSpawn());
+            ProtocolUtils.sendPayloadPacket(player, INITIALIZE_CLIENT, buf);
+
+            final Registry<Structure> structureRegistry = player.server.registryAccess().registryOrThrow(Registries.STRUCTURE);
+            final Set<String> structureIds = structureRegistry.entrySet().stream().map(e -> e.getKey().location().toString()).collect(Collectors.toSet());
+            FriendlyByteBuf buf1 = new FriendlyByteBuf(Unpooled.buffer());
+            buf1.writeVarInt(structureIds.size());
+            structureIds.forEach(buf1::writeUtf);
+            ProtocolUtils.sendPayloadPacket(player, STRUCTURE_LIST_SYNC, buf1);
+        }
+    }
+
+    public static void onPlayerSubscribed(@NotNull ServerPlayer player) {
+        if (MoliaConfig.enablePCASyncProtocol) {
+            players.put(player.getId(), player);
+            sendBoundingToPlayer(player.getId(), player);
+        }
+    }
+
+    public static void onDataPackReload() {
+        if (MoliaConfig.enablePCASyncProtocol) {
+            for (var playerEntry : players.entrySet()) {
+                final Registry<Structure> structureRegistry = MinecraftServer.getServer().registryAccess().registryOrThrow(Registries.STRUCTURE);
+                final Set<String> structureIds = structureRegistry.entrySet().stream().map(e -> e.getKey().location().toString()).collect(Collectors.toSet());
+                FriendlyByteBuf buf = new FriendlyByteBuf(Unpooled.buffer());
+                buf.writeVarInt(structureIds.size());
+                structureIds.forEach(buf::writeUtf);
+                ProtocolUtils.sendPayloadPacket(playerEntry.getValue(), STRUCTURE_LIST_SYNC, buf);
+            }
+        }
+    }
+
+    public static void onPlayerLoggedOut(@NotNull ServerPlayer player) {
+        if (MoliaConfig.enablePCASyncProtocol) {
+            players.remove(player.getId());
+            playerBoundingBoxesCache.remove(player.getId());
+        }
+    }
+
+    public static void onChunkLoaded(@NotNull LevelChunk chunk) {
+        if (MoliaConfig.enablePCASyncProtocol) {
+            Map<String, StructureStart> structures = new HashMap<>();
+            final Registry<Structure> structureFeatureRegistry = chunk.getLevel().registryAccess().registryOrThrow(Registries.STRUCTURE);
+            for (var es : chunk.getAllStarts().entrySet()) {
+                final var optional = structureFeatureRegistry.getResourceKey(es.getKey());
+                optional.ifPresent(key -> structures.put(key.location().toString(), es.getValue()));
+            }
+            if (structures.size() > 0) {
+                onStructuresLoaded(chunk.getLevel().dimension().location(), structures);
+            }
+        }
+    }
+
+    public static void onStructuresLoaded(@NotNull ResourceLocation dimensionID, @NotNull Map<String, StructureStart> structures) {
+        Map<BBoundingBox, Set<BBoundingBox>> cache = getOrCreateCache(dimensionID);
+        for (var entry : structures.entrySet()) {
+            StructureStart structureStart = entry.getValue();
+            if (structureStart == null) {
+                return;
+            }
+
+            String type = "structure:" + entry.getKey();
+            BoundingBox bb = structureStart.getBoundingBox();
+            BBoundingBox boundingBox = buildStructure(bb, type);
+            if (cache.containsKey(boundingBox)) {
+                return;
+            }
+
+            Set<BBoundingBox> structureBoundingBoxes = new HashSet<>();
+            for (StructurePiece structureComponent : structureStart.getPieces()) {
+                structureBoundingBoxes.add(buildStructure(structureComponent.getBoundingBox(), type));
+            }
+            cache.put(boundingBox, structureBoundingBoxes);
+        }
+    }
+
+    private static @NotNull BBoundingBox buildStructure(@NotNull BoundingBox bb, String type) {
+        BlockPos min = new BlockPos(bb.minX(), bb.minY(), bb.minZ());
+        BlockPos max = new BlockPos(bb.maxX(), bb.maxY(), bb.maxZ());
+        return new BBoundingBox(type, min, max);
+    }
+
+    private static void sendBoundingToPlayer(int id, ServerPlayer player) {
+        for (var entry : dimensionCache.entrySet()) {
+            if (entry.getValue() == null) {
+                return;
+            }
+
+            Set<BBoundingBox> playerBoundingBoxes = playerBoundingBoxesCache.computeIfAbsent(id, k -> new HashSet<>());
+            Map<BBoundingBox, Set<BBoundingBox>> boundingBoxMap = entry.getValue();
+            for (BBoundingBox key : boundingBoxMap.keySet()) {
+                if (playerBoundingBoxes.contains(key)) {
+                    continue;
+                }
+
+                Set<BBoundingBox> boundingBoxes = boundingBoxMap.get(key);
+
+                FriendlyByteBuf buf = new FriendlyByteBuf(Unpooled.buffer());
+                buf.writeResourceLocation(entry.getKey());
+                key.serialize(buf);
+                if (boundingBoxes != null && boundingBoxes.size() > 1) {
+                    for (BBoundingBox box : boundingBoxes) {
+                        box.serialize(buf);
+                    }
+                }
+                ProtocolUtils.sendPayloadPacket(player, ADD_BOUNDING_BOX, buf);
+                playerBoundingBoxes.add(key);
+            }
+        }
+    }
+
+    public static void tick() {
+        if (MoliaConfig.enablePCASyncProtocol) {
+            for (var playerEntry : players.entrySet()) {
+                sendBoundingToPlayer(playerEntry.getKey(), playerEntry.getValue());
+            }
+        }
+    }
+
+    public static void initAllPlayer() {
+        for (ServerPlayer player : MinecraftServer.getServer().getPlayerList().getPlayers()) {
+            onPlayerLoggedIn(player);
+        }
+    }
+
+    public static void loggedOutAllPlayer() {
+        players.clear();
+        playerBoundingBoxesCache.clear();
+        for (var cache : dimensionCache.values()) {
+            cache.clear();
+        }
+        dimensionCache.clear();
+    }
+
+    private static Map<BBoundingBox, Set<BBoundingBox>> getOrCreateCache(ResourceLocation dimensionId) {
+        return dimensionCache.computeIfAbsent(dimensionId, dt -> new ConcurrentHashMap<>());
+    }
+
+    private record BBoundingBox(String type, BlockPos min, BlockPos max) {
+
+        public void serialize(@NotNull FriendlyByteBuf buf) {
+            buf.writeChar('S');
+            buf.writeInt(type.hashCode());
+            buf.writeVarInt(min.getX()).writeVarInt(min.getY()).writeVarInt(min.getZ());
+            buf.writeVarInt(max.getX()).writeVarInt(max.getY()).writeVarInt(max.getZ());
+        }
+
+        @Override
+        public int hashCode() {
+            return combineHashCodes(min.hashCode(), max.hashCode());
+        }
+
+        private static int combineHashCodes(int @NotNull ... hashCodes) {
+            final int prime = 31;
+            int result = 0;
+            for (int hashCode : hashCodes) {
+                result = prime * result + hashCode;
+            }
+            return result;
+        }
+    }
+}
diff --git a/src/main/java/top/leavesmc/leaves/protocol/CarpetAlternativeBlockPlacement.java b/src/main/java/top/leavesmc/leaves/protocol/CarpetAlternativeBlockPlacement.java
new file mode 100644
index 0000000000000000000000000000000000000000..848c380ed3d9755bab680b1e244a6024110bc383
--- /dev/null
+++ b/src/main/java/top/leavesmc/leaves/protocol/CarpetAlternativeBlockPlacement.java
@@ -0,0 +1,101 @@
+package top.leavesmc.leaves.protocol;
+
+import net.minecraft.core.BlockPos;
+import net.minecraft.core.Direction;
+import net.minecraft.world.item.context.BlockPlaceContext;
+import net.minecraft.world.level.block.BedBlock;
+import net.minecraft.world.level.block.Block;
+import net.minecraft.world.level.block.ComparatorBlock;
+import net.minecraft.world.level.block.RepeaterBlock;
+import net.minecraft.world.level.block.state.BlockState;
+import net.minecraft.world.level.block.state.properties.BlockStateProperties;
+import net.minecraft.world.level.block.state.properties.ComparatorMode;
+import net.minecraft.world.level.block.state.properties.DirectionProperty;
+import net.minecraft.world.level.block.state.properties.Half;
+import net.minecraft.world.level.block.state.properties.Property;
+import net.minecraft.world.level.block.state.properties.SlabType;
+import net.minecraft.world.phys.Vec3;
+import org.jetbrains.annotations.NotNull;
+
+import javax.annotation.Nullable;
+
+public class CarpetAlternativeBlockPlacement {
+
+    @Nullable
+    public static BlockState alternativeBlockPlacement(@NotNull Block block, @NotNull BlockPlaceContext context) {
+        Vec3 hitPos = context.getClickLocation();
+        BlockPos blockPos = context.getClickedPos();
+        double relativeHitX = hitPos.x - blockPos.getX();
+        BlockState state = block.getStateForPlacement(context);
+
+        if (relativeHitX < 2 || state == null) {
+            return null;
+        }
+
+        DirectionProperty directionProp = getFirstDirectionProperty(state);
+        int protocolValue = ((int) relativeHitX - 2) / 2;
+
+        if (directionProp != null) {
+            Direction origFacing = state.getValue(directionProp);
+            Direction facing = origFacing;
+            int facingIndex = protocolValue & 0xF;
+
+            if (facingIndex == 6) {
+                facing = facing.getOpposite();
+            } else if (facingIndex <= 5) {
+                facing = Direction.from3DDataValue(facingIndex);
+            }
+
+            if (!directionProp.getPossibleValues().contains(facing)) {
+                facing = context.getPlayer().getDirection().getOpposite();
+            }
+
+            if (facing != origFacing && directionProp.getPossibleValues().contains(facing)) {
+                if (state.getBlock() instanceof BedBlock) {
+                    BlockPos headPos = blockPos.relative(facing);
+
+                    if (!context.getLevel().getBlockState(headPos).canBeReplaced(context)) {
+                        return null;
+                    }
+                }
+
+                state = state.setValue(directionProp, facing);
+            }
+        } else if (state.hasProperty(BlockStateProperties.AXIS)) {
+            Direction.Axis axis = Direction.Axis.VALUES[protocolValue % 3];
+            state = state.setValue(BlockStateProperties.AXIS, axis);
+        }
+
+        protocolValue &= 0xFFFFFFF0;
+
+        if (protocolValue >= 16) {
+            if (block instanceof RepeaterBlock) {
+                Integer delay = (protocolValue / 16);
+
+                if (RepeaterBlock.DELAY.getPossibleValues().contains(delay)) {
+                    state = state.setValue(RepeaterBlock.DELAY, delay);
+                }
+            } else if (protocolValue == 16) {
+                if (block instanceof ComparatorBlock) {
+                    state = state.setValue(ComparatorBlock.MODE, ComparatorMode.SUBTRACT);
+                } else if (state.hasProperty(BlockStateProperties.HALF) && state.getValue(BlockStateProperties.HALF) == Half.BOTTOM) {
+                    state = state.setValue(BlockStateProperties.HALF, Half.TOP);
+                } else if (state.hasProperty(BlockStateProperties.SLAB_TYPE) && state.getValue(BlockStateProperties.SLAB_TYPE) == SlabType.BOTTOM) {
+                    state = state.setValue(BlockStateProperties.SLAB_TYPE, SlabType.TOP);
+                }
+            }
+        }
+
+        return state;
+    }
+
+    @Nullable
+    public static DirectionProperty getFirstDirectionProperty(@NotNull BlockState state) {
+        for (Property<?> prop : state.getProperties()) {
+            if (prop instanceof DirectionProperty) {
+                return (DirectionProperty) prop;
+            }
+        }
+        return null;
+    }
+}
diff --git a/src/main/java/top/leavesmc/leaves/protocol/PcaSyncProtocol.java b/src/main/java/top/leavesmc/leaves/protocol/PcaSyncProtocol.java
new file mode 100644
index 0000000000000000000000000000000000000000..108d841a8ac58ea3d445146a988d62dc4aa057cc
--- /dev/null
+++ b/src/main/java/top/leavesmc/leaves/protocol/PcaSyncProtocol.java
@@ -0,0 +1,357 @@
+package top.leavesmc.leaves.protocol;
+
+import io.netty.buffer.Unpooled;
+import me.earthme.molia.MoliaConfig;
+import net.minecraft.core.BlockPos;
+import net.minecraft.nbt.CompoundTag;
+import net.minecraft.network.FriendlyByteBuf;
+import net.minecraft.network.protocol.game.ServerboundCustomPayloadPacket;
+import net.minecraft.resources.ResourceLocation;
+import net.minecraft.server.MinecraftServer;
+import net.minecraft.server.level.ServerLevel;
+import net.minecraft.server.level.ServerPlayer;
+import net.minecraft.world.entity.Entity;
+import net.minecraft.world.entity.player.Player;
+import net.minecraft.world.level.Level;
+import net.minecraft.world.level.block.ChestBlock;
+import net.minecraft.world.level.block.entity.BlockEntity;
+import net.minecraft.world.level.block.state.BlockState;
+import net.minecraft.world.level.block.state.properties.ChestType;
+import org.apache.commons.lang3.tuple.ImmutablePair;
+import org.apache.commons.lang3.tuple.MutablePair;
+import org.apache.commons.lang3.tuple.Pair;
+import org.apache.logging.log4j.util.TriConsumer;
+import org.jetbrains.annotations.Contract;
+import org.jetbrains.annotations.NotNull;
+import org.jetbrains.annotations.Nullable;
+import top.leavesmc.leaves.LeavesLogger;
+import top.leavesmc.leaves.bot.ServerBot;
+import top.leavesmc.leaves.util.ProtocolUtils;
+
+import java.util.HashMap;
+import java.util.HashSet;
+import java.util.Map;
+import java.util.Set;
+import java.util.concurrent.locks.ReentrantLock;
+
+public class PcaSyncProtocol {
+
+    public static final String PROTOCOL_ID = "pca";
+
+    public static final ReentrantLock lock = new ReentrantLock(true);
+    public static final ReentrantLock pairLock = new ReentrantLock(true);
+
+    // send
+    private static final ResourceLocation ENABLE_PCA_SYNC_PROTOCOL = id("enable_pca_sync_protocol");
+    private static final ResourceLocation DISABLE_PCA_SYNC_PROTOCOL = id("disable_pca_sync_protocol");
+    private static final ResourceLocation UPDATE_ENTITY = id("update_entity");
+    private static final ResourceLocation UPDATE_BLOCK_ENTITY = id("update_block_entity");
+    // call
+    private static final ResourceLocation SYNC_BLOCK_ENTITY = id("sync_block_entity");
+    private static final ResourceLocation SYNC_ENTITY = id("sync_entity");
+    private static final ResourceLocation CANCEL_SYNC_BLOCK_ENTITY = id("cancel_sync_block_entity");
+    private static final ResourceLocation CANCEL_SYNC_ENTITY = id("cancel_sync_entity");
+    private static final Map<ServerPlayer, Pair<ResourceLocation, BlockPos>> playerWatchBlockPos = new HashMap<>();
+    private static final Map<ServerPlayer, Pair<ResourceLocation, Entity>> playerWatchEntity = new HashMap<>();
+    private static final Map<Pair<ResourceLocation, BlockPos>, Set<ServerPlayer>> blockPosWatchPlayerSet = new HashMap<>();
+    private static final Map<Pair<ResourceLocation, Entity>, Set<ServerPlayer>> entityWatchPlayerSet = new HashMap<>();
+    private static final MutablePair<ResourceLocation, Entity> ResourceLocationEntityPair = new MutablePair<>();
+    private static final MutablePair<ResourceLocation, BlockPos> ResourceLocationBlockPosPair = new MutablePair<>();
+
+    @Contract("_ -> new")
+    public static @NotNull ResourceLocation id(String path) {
+        return new ResourceLocation(PROTOCOL_ID, path);
+    }
+
+    public static void enablePcaSyncProtocol(@NotNull ServerPlayer player) {
+        FriendlyByteBuf buf = new FriendlyByteBuf(Unpooled.buffer());
+        ProtocolUtils.sendPayloadPacket(player, ENABLE_PCA_SYNC_PROTOCOL, buf);
+        lock.lock();
+        lock.unlock();
+    }
+
+    public static void disablePcaSyncProtocol(@NotNull ServerPlayer player) {
+        FriendlyByteBuf buf = new FriendlyByteBuf(Unpooled.buffer());
+        ProtocolUtils.sendPayloadPacket(player, DISABLE_PCA_SYNC_PROTOCOL, buf);
+    }
+
+    public static void updateEntity(@NotNull ServerPlayer player, @NotNull Entity entity) {
+        FriendlyByteBuf buf = new FriendlyByteBuf(Unpooled.buffer());
+        buf.writeResourceLocation(entity.level().dimension().location());
+        buf.writeInt(entity.getId());
+        buf.writeNbt(entity.saveWithoutId(new CompoundTag()));
+        ProtocolUtils.sendPayloadPacket(player, UPDATE_ENTITY, buf);
+    }
+
+    public static void updateBlockEntity(@NotNull ServerPlayer player, @NotNull BlockEntity blockEntity) {
+        Level world = blockEntity.getLevel();
+
+        if (world == null) {
+            return;
+        }
+
+        FriendlyByteBuf buf = new FriendlyByteBuf(Unpooled.buffer());
+        buf.writeResourceLocation(world.dimension().location());
+        buf.writeBlockPos(blockEntity.getBlockPos());
+        buf.writeNbt(blockEntity.saveWithId());
+        ProtocolUtils.sendPayloadPacket(player, UPDATE_BLOCK_ENTITY, buf);
+    }
+
+    private static final Map<ResourceLocation, TriConsumer<MinecraftServer, ServerPlayer, FriendlyByteBuf>> globalReceivers = new HashMap<>();
+
+    private static void registerGlobalReceiver(ResourceLocation identifier, TriConsumer<MinecraftServer, ServerPlayer, FriendlyByteBuf> consumer) {
+        globalReceivers.put(identifier, consumer);
+    }
+
+    public static void handlePacket(MinecraftServer server, ServerPlayer player, @NotNull ServerboundCustomPayloadPacket packet) {
+        globalReceivers.getOrDefault(
+            packet.identifier, ((server1, player1, buf) -> LeavesLogger.LOGGER.severe("NullPotion"))
+        ).accept(server, player, packet.data);
+    }
+
+    public static void init() {
+        registerGlobalReceiver(SYNC_BLOCK_ENTITY, PcaSyncProtocol::syncBlockEntityHandler);
+        registerGlobalReceiver(SYNC_ENTITY, PcaSyncProtocol::syncEntityHandler);
+        registerGlobalReceiver(CANCEL_SYNC_BLOCK_ENTITY, PcaSyncProtocol::cancelSyncBlockEntityHandler);
+        registerGlobalReceiver(CANCEL_SYNC_ENTITY, PcaSyncProtocol::cancelSyncEntityHandler);
+    }
+
+    public static void onJoin(ServerPlayer player) {
+        if (MoliaConfig.enablePCASyncProtocol) {
+            enablePcaSyncProtocol(player);
+        }
+    }
+
+    private static void cancelSyncBlockEntityHandler(MinecraftServer server, ServerPlayer player,
+                                                     FriendlyByteBuf buf) {
+        if (!MoliaConfig.enablePCASyncProtocol) {
+            return;
+        }
+        PcaSyncProtocol.clearPlayerWatchBlock(player);
+    }
+
+    private static void cancelSyncEntityHandler(MinecraftServer server, ServerPlayer player,
+                                                FriendlyByteBuf buf) {
+        if (!MoliaConfig.enablePCASyncProtocol) {
+            return;
+        }
+        PcaSyncProtocol.clearPlayerWatchEntity(player);
+    }
+
+    private static void syncBlockEntityHandler(MinecraftServer server, ServerPlayer player,
+                                               FriendlyByteBuf buf) {
+        if (!MoliaConfig.enablePCASyncProtocol) {
+            return;
+        }
+        BlockPos pos = buf.readBlockPos();
+        ServerLevel world = player.serverLevel();
+        BlockState blockState = world.getBlockState(pos);
+        clearPlayerWatchData(player);
+
+        BlockEntity blockEntityAdj = null;
+        if (blockState.getBlock() instanceof ChestBlock) {
+            if (blockState.getValue(ChestBlock.TYPE) != ChestType.SINGLE) {
+                BlockPos posAdj = pos.offset(ChestBlock.getConnectedDirection(blockState).getNormal());
+                // The method in World now checks that the caller is from the same thread...
+                blockEntityAdj = world.getChunk(posAdj).getBlockEntity(posAdj);
+            }
+        }
+
+        if (blockEntityAdj != null) {
+            updateBlockEntity(player, blockEntityAdj);
+        }
+
+        // The method in World now checks that the caller is from the same thread...
+        BlockEntity blockEntity = world.getChunk(pos).getBlockEntity(pos);
+        if (blockEntity != null) {
+            updateBlockEntity(player, blockEntity);
+        }
+
+        Pair<ResourceLocation, BlockPos> pair = new ImmutablePair<>(player.level().dimension().location(), pos);
+        lock.lock();
+        playerWatchBlockPos.put(player, pair);
+        if (!blockPosWatchPlayerSet.containsKey(pair)) {
+            blockPosWatchPlayerSet.put(pair, new HashSet<>());
+        }
+        blockPosWatchPlayerSet.get(pair).add(player);
+        lock.unlock();
+    }
+
+    private static void syncEntityHandler(MinecraftServer server, ServerPlayer player,
+                                          FriendlyByteBuf buf) {
+        if (!MoliaConfig.enablePCASyncProtocol) {
+            return;
+        }
+        int entityId = buf.readInt();
+        ServerLevel world = player.serverLevel();
+        Entity entity = world.getEntity(entityId);
+        if (entity != null) {
+            clearPlayerWatchData(player);
+            if (entity instanceof Player) {
+                if (MoliaConfig.pcaSyncPlayerEntity.equals("NOBODY")) {
+                    return;
+                } else if (MoliaConfig.pcaSyncPlayerEntity.equals("BOT")) {
+                    if (!(entity instanceof ServerBot)) {
+                        return;
+                    }
+                } else if (MoliaConfig.pcaSyncPlayerEntity.equals("OPS")) {
+                    if (!(entity instanceof ServerBot) && server.getProfilePermissions(player.getGameProfile()) < 2) {
+                        return;
+                    }
+                } else if (MoliaConfig.pcaSyncPlayerEntity.equals("OPS_AND_SELF")) {
+                    if (!(entity instanceof ServerBot) &&
+                        server.getProfilePermissions(player.getGameProfile()) < 2 &&
+                        entity != player) {
+                        return;
+                    }
+                } else if (!MoliaConfig.pcaSyncPlayerEntity.equals("EVERYONE")) {
+                    // wtf????
+                    LeavesLogger.LOGGER.warning("pcaSyncPlayerEntity wtf???");
+                    return;
+                }
+            }
+            updateEntity(player, entity);
+
+            Pair<ResourceLocation, Entity> pair = new ImmutablePair<>(entity.level().dimension().location(), entity);
+            lock.lock();
+            playerWatchEntity.put(player, pair);
+            if (!entityWatchPlayerSet.containsKey(pair)) {
+                entityWatchPlayerSet.put(pair, new HashSet<>());
+            }
+            entityWatchPlayerSet.get(pair).add(player);
+            lock.unlock();
+        }
+    }
+
+    private static MutablePair<ResourceLocation, Entity> getResourceLocationEntityPair(ResourceLocation ResourceLocation, Entity entity) {
+        pairLock.lock();
+        ResourceLocationEntityPair.setLeft(ResourceLocation);
+        ResourceLocationEntityPair.setRight(entity);
+        pairLock.unlock();
+        return ResourceLocationEntityPair;
+    }
+
+    private static MutablePair<ResourceLocation, BlockPos> getResourceLocationBlockPosPair(ResourceLocation ResourceLocation, BlockPos pos) {
+        pairLock.lock();
+        ResourceLocationBlockPosPair.setLeft(ResourceLocation);
+        ResourceLocationBlockPosPair.setRight(pos);
+        pairLock.unlock();
+        return ResourceLocationBlockPosPair;
+    }
+
+    private static @Nullable Set<ServerPlayer> getWatchPlayerList(@NotNull Entity entity) {
+        return entityWatchPlayerSet.get(getResourceLocationEntityPair(entity.level().dimension().location(), entity));
+    }
+
+    private static @Nullable Set<ServerPlayer> getWatchPlayerList(@NotNull Level world, @NotNull BlockPos blockPos) {
+        return blockPosWatchPlayerSet.get(getResourceLocationBlockPosPair(world.dimension().location(), blockPos));
+    }
+
+    public static boolean syncEntityToClient(@NotNull Entity entity) {
+        if (entity.level().isClientSide()) {
+            return false;
+        }
+        lock.lock();
+        Set<ServerPlayer> playerList = getWatchPlayerList(entity);
+        boolean ret = false;
+        if (playerList != null) {
+            for (ServerPlayer player : playerList) {
+                updateEntity(player, entity);
+                ret = true;
+            }
+        }
+        lock.unlock();
+        return ret;
+    }
+
+    public static boolean syncBlockEntityToClient(@NotNull BlockEntity blockEntity) {
+        boolean ret = false;
+        Level world = blockEntity.getLevel();
+        BlockPos pos = blockEntity.getBlockPos();
+        if (world != null) {
+            if (world.isClientSide()) {
+                return false;
+            }
+            BlockState blockState = world.getBlockState(pos);
+            lock.lock();
+            Set<ServerPlayer> playerList = getWatchPlayerList(world, blockEntity.getBlockPos());
+
+            Set<ServerPlayer> playerListAdj = null;
+
+            if (blockState.getBlock() instanceof ChestBlock) {
+                if (blockState.getValue(ChestBlock.TYPE) != ChestType.SINGLE) {
+                    BlockPos posAdj = pos.offset(ChestBlock.getConnectedDirection(blockState).getNormal());
+                    playerListAdj = getWatchPlayerList(world, posAdj);
+                }
+            }
+            if (playerListAdj != null) {
+                if (playerList == null) {
+                    playerList = playerListAdj;
+                } else {
+                    playerList.addAll(playerListAdj);
+                }
+            }
+
+            if (playerList != null) {
+                for (ServerPlayer player : playerList) {
+                    updateBlockEntity(player, blockEntity);
+                    ret = true;
+                }
+            }
+            lock.unlock();
+        }
+        return ret;
+    }
+
+    private static void clearPlayerWatchEntity(ServerPlayer player) {
+        lock.lock();
+        Pair<ResourceLocation, Entity> pair = playerWatchEntity.get(player);
+        if (pair != null) {
+            Set<ServerPlayer> playerSet = entityWatchPlayerSet.get(pair);
+            playerSet.remove(player);
+            if (playerSet.isEmpty()) {
+                entityWatchPlayerSet.remove(pair);
+            }
+            playerWatchEntity.remove(player);
+        }
+        lock.unlock();
+    }
+
+    private static void clearPlayerWatchBlock(ServerPlayer player) {
+        lock.lock();
+        Pair<ResourceLocation, BlockPos> pair = playerWatchBlockPos.get(player);
+        if (pair != null) {
+            Set<ServerPlayer> playerSet = blockPosWatchPlayerSet.get(pair);
+            playerSet.remove(player);
+            if (playerSet.isEmpty()) {
+                blockPosWatchPlayerSet.remove(pair);
+            }
+            playerWatchBlockPos.remove(player);
+        }
+        lock.unlock();
+    }
+
+    public static void disablePcaSyncProtocolGlobal() {
+        lock.lock();
+        playerWatchBlockPos.clear();
+        playerWatchEntity.clear();
+        blockPosWatchPlayerSet.clear();
+        entityWatchPlayerSet.clear();
+        lock.unlock();
+        for (ServerPlayer player : MinecraftServer.getServer().getPlayerList().getPlayers()) {
+            disablePcaSyncProtocol(player);
+        }
+    }
+
+    public static void enablePcaSyncProtocolGlobal() {
+        for (ServerPlayer player : MinecraftServer.getServer().getPlayerList().getPlayers()) {
+            enablePcaSyncProtocol(player);
+        }
+    }
+
+
+    public static void clearPlayerWatchData(ServerPlayer player) {
+        PcaSyncProtocol.clearPlayerWatchBlock(player);
+        PcaSyncProtocol.clearPlayerWatchEntity(player);
+    }
+}
